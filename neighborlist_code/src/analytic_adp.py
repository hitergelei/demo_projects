from ase import Atoms
from ase.io import read, write
from ase.build import bulk, make_supercell
from ase.neighborlist import NeighborList
from ase.calculators.eam import EAM
import matplotlib.pyplot as plt
# from eam_code import EAM_chj
import numpy as np
import asap3
from torch_neigh import TorchNeighborList
from adp_func import emb, emb_vec, rho, phi_AA, u11, w11

# vesin也提供了近邻列表的计算
# https://github.com/Luthaf/vesin

def test_adp():
    
    # atoms_obj = read("Ta.xxx.dat", format="lammps-data")
    # expanded_atoms = read("test_examples2/dump.lammpstrj", format="lammps-dump-text")  # Ta SC221的晶胞

    # print("\n----------------TorchNeighborList方法")

    # cutoff = 3.0   # 截断半径
    # cutoff = 6.150958970000000   # Ta的adp势文件中实际的截断半径
    # # 实例化邻居列表类
    # neighbor_list = TorchNeighborList(cutoff=cutoff)

    # # 计算近邻列表
    # pairs, pair_diff, pair_dist = neighbor_list(atoms_obj)

    # print("len(pairs) = ", len(pairs))
    # # pairs包含原子对的索引，pair_diff是原子对之间的向量差，pair_dist是原子对之间的距离
    # print("Pairs:\n", pairs)
    # print("pair_diff形状：", pair_diff.shape)
    # print("Pair differences:\n", pair_diff)
    # print("Pair distances:\n", pair_dist)

    # Mo_adp1 = EAM(potential="./test_Mo_adp/Mo.adp", elements=['Mo'], form='adp')
    # Mo_adp1.calculate(properties='energy', atoms=expanded_atoms)
    # Mo_adp1.plot('Mo_adp1')
    # Mo_adp2 = EAM(potential="./test_Mo_adp/hjchen-Mo.adp", elements=['Mo'], form='adp')
    # Mo_adp2.plot('Mo_adp-hjchen')

    # Ta_adp = EAM(potential="Ta.adp.txt", elements=['Ta'], form='adp')
    # Ta_adp.plot('Ta_adp')


    # Ta_adp = EAM(potential="CuTa_LJ15_2014.adp.txt", elements=['Cu', 'Ta'], form='adp')
    # Ta_adp.plot('CuTa_adp')

    # CrNi_adp = EAM(potential="2018-CrNi.adp.txt", elements=['Cr', 'Ni'], form='adp')
    # CrNi_adp.plot('2018-CrNi_adp')
    pass

# TODO: 根据ase.calculators.eam.EAM中的函数修改
def calculate_energy(self, atoms):
    """Calculate the energy
    the energy is made up of the ionic or pair interaction and
    the embedding energy of each atom into the electron cloud
    generated by its neighbors
    """

    pair_energy = 0.0
    embedding_energy = 0.0
    mu_energy = 0.0
    lam_energy = 0.0
    trace_energy = 0.0

    self.total_density = np.zeros(len(atoms))
    if (self.form == 'adp'):
        self.mu = np.zeros([len(atoms), 3])
        self.lam = np.zeros([len(atoms), 3, 3])

    for i in range(len(atoms)):  # this is the atom to be embedded
        neighbors, offsets = self.neighbors.get_neighbors(i)
        offset = np.dot(offsets, atoms.get_cell())

        rvec = (atoms.positions[neighbors] + offset -
                atoms.positions[i])

        # calculate the distance to the nearest neighbors
        r = np.sqrt(np.sum(np.square(rvec), axis=1))  # fast
#            r = np.apply_along_axis(np.linalg.norm, 1, rvec)  # sloow

        nearest = np.arange(len(r))[r <= self.cutoff]
        for j_index in range(self.Nelements):
            use = self.index[neighbors[nearest]] == j_index
            if not use.any():
                continue
            pair_energy += np.sum(self.phi[self.index[i], j_index](
                r[nearest][use])) / 2.

            if self.form == 'fs':
                density = np.sum(
                    self.electron_density[j_index, self.index[i]](r[nearest][use]))
            else:
                density = np.sum(
                    self.electron_density[j_index](r[nearest][use]))
            self.total_density[i] += density

            if self.form == 'adp':
                self.mu[i] += self.adp_dipole(
                    r[nearest][use],
                    rvec[nearest][use],
                    self.d[self.index[i], j_index])

                self.lam[i] += self.adp_quadrupole(
                    r[nearest][use],
                    rvec[nearest][use],
                    self.q[self.index[i], j_index])

        # add in the electron embedding energy
        embedding_energy += self.embedded_energy[self.index[i]](
            self.total_density[i])

    components = dict(pair=pair_energy, embedding=embedding_energy)

    if self.form == 'adp':
        mu_energy += np.sum(self.mu ** 2) / 2.
        lam_energy += np.sum(self.lam ** 2) / 2.

        for i in range(len(atoms)):  # this is the atom to be embedded
            trace_energy -= np.sum(self.lam[i].trace() ** 2) / 6.

        adp_result = dict(adp_mu=mu_energy,
                            adp_lam=lam_energy,
                            adp_trace=trace_energy)
        components.update(adp_result)

    self.positions = atoms.positions.copy()
    self.cell = atoms.get_cell().copy()

    energy = 0.0
    for i in components.keys():
        energy += components[i]

    self.energy_free = energy
    self.energy_zero = energy

    self.results['energy_components'] = components
    self.results['energy'] = energy




def calculate_forces(self, atoms):
    # calculate the forces based on derivatives of the three EAM functions

    self.update(atoms)
    self.results['forces'] = np.zeros((len(atoms), 3))

    for i in range(len(atoms)):  # this is the atom to be embedded
        neighbors, offsets = self.neighbors.get_neighbors(i)
        offset = np.dot(offsets, atoms.get_cell())
        # create a vector of relative positions of neighbors
        rvec = atoms.positions[neighbors] + offset - atoms.positions[i]
        r = np.sqrt(np.sum(np.square(rvec), axis=1))
        nearest = np.arange(len(r))[r < self.cutoff]

        d_embedded_energy_i = self.d_embedded_energy[
            self.index[i]](self.total_density[i])
        urvec = rvec.copy()  # unit directional vector

        for j in np.arange(len(neighbors)):
            urvec[j] = urvec[j] / r[j]

        for j_index in range(self.Nelements):
            use = self.index[neighbors[nearest]] == j_index
            if not use.any():
                continue
            rnuse = r[nearest][use]
            density_j = self.total_density[neighbors[nearest][use]]
            if self.form == 'fs':
                scale = (self.d_phi[self.index[i], j_index](rnuse) +
                            (d_embedded_energy_i *
                            self.d_electron_density[j_index, self.index[i]](rnuse)) +
                            (self.d_embedded_energy[j_index](density_j) *
                            self.d_electron_density[self.index[i], j_index](rnuse)))
            else:
                scale = (self.d_phi[self.index[i], j_index](rnuse) +
                            (d_embedded_energy_i *
                            self.d_electron_density[j_index](rnuse)) +
                            (self.d_embedded_energy[j_index](density_j) *
                            self.d_electron_density[self.index[i]](rnuse)))

            self.results['forces'][i] += np.dot(scale, urvec[nearest][use])

            if (self.form == 'adp'):
                adp_forces = self.angular_forces(
                    self.mu[i],
                    self.mu[neighbors[nearest][use]],
                    self.lam[i],
                    self.lam[neighbors[nearest][use]],
                    rnuse,
                    rvec[nearest][use],
                    self.index[i],
                    j_index)

                self.results['forces'][i] += adp_forces


def angular_forces(self, mu_i, mu, lam_i, lam, r, rvec, form1, form2):
    # calculate the extra components for the adp forces
    # rvec are the relative positions to atom i
    psi = np.zeros(mu.shape)
    for gamma in range(3):
        term1 = (mu_i[gamma] - mu[:, gamma]) * self.d[form1][form2](r)

        term2 = np.sum((mu_i - mu) *
                        self.d_d[form1][form2](r)[:, np.newaxis] *
                        (rvec * rvec[:, gamma][:, np.newaxis] /
                        r[:, np.newaxis]), axis=1)

        term3 = 2 * np.sum((lam_i[:, gamma] + lam[:, :, gamma]) *
                            rvec * self.q[form1][form2](r)[:, np.newaxis],
                            axis=1)
        term4 = 0.0
        for alpha in range(3):
            for beta in range(3):
                rs = rvec[:, alpha] * rvec[:, beta] * rvec[:, gamma]
                term4 += ((lam_i[alpha, beta] + lam[:, alpha, beta]) *
                            self.d_q[form1][form2](r) * rs) / r

        term5 = ((lam_i.trace() + lam.trace(axis1=1, axis2=2)) *
                    (self.d_q[form1][form2](r) * r +
                    2 * self.q[form1][form2](r)) * rvec[:, gamma]) / 3.

        # the minus for term5 is a correction on the adp
        # formulation given in the 2005 Mishin Paper and is posted
        # on the NIST website with the AlH potential
        psi[:, gamma] = term1 + term2 + term3 + term4 - term5

    return np.sum(psi, axis=0)

def adp_dipole(self, r, rvec, d):
    # calculate the dipole contribution
    mu = np.sum((rvec * d(r)[:, np.newaxis]), axis=0)

    return mu  # sign to agree with lammps

def adp_quadrupole(self, r, rvec, q):
    # slow way of calculating the quadrupole contribution
    r = np.sqrt(np.sum(rvec ** 2, axis=1))

    lam = np.zeros([rvec.shape[0], 3, 3])
    qr = q(r)
    for alpha in range(3):
        for beta in range(3):
            lam[:, alpha, beta] += qr * rvec[:, alpha] * rvec[:, beta]

    return np.sum(lam, axis=0)

# via hjchen
class ADP:

    def __init__(self, atoms_obj: Atoms, cutoff:float):
        # since we need the contribution of all neighbors to the
        # local electron density we cannot just calculate and use
        # one way neighbors
        atoms = atoms_obj
        self.cutoff = cutoff
        # cutoffs need to be a vector for NeighborList
        cutoffs = self.cutoff * np.ones(len(atoms))
        # print(cutoffs)
        self.neighbors = NeighborList(cutoffs,
                                      skin=0,   # 这里用的是bin=0
                                      self_interaction=False,
                                      bothways=True)
        self.neighbors.update(atoms)
    def calc_energy(self, atoms_obj: Atoms):
        
        pair_energy = 0.0
        embedding_energy = 0.0
        mu_energy = 0.0
        lam_energy = 0.0
        trace_energy = 0.0
        
        atoms = atoms_obj
        
        self.total_density = np.zeros(len(atoms))

        self.mu = np.zeros([len(atoms), 3])
        self.lam = np.zeros([len(atoms), 3, 3])
        
        for i in range(len(atoms)):  # this is the atom to be embedded
            neighbors, offsets = self.neighbors.get_neighbors(i)
            offset = np.dot(offsets, atoms.get_cell())

            rvec = (atoms.positions[neighbors] + offset -
                    atoms.positions[i])

            # calculate the distance to the nearest neighbors
            r = np.sqrt(np.sum(np.square(rvec), axis=1))  # fast
#            r = np.apply_along_axis(np.linalg.norm, 1, rvec)  # sloow
            
            print('atomi = {}, len(r) = {}'.format(i, len(r)))
        
def ase_neigh(atoms_obj: Atoms, cutoff: float):  
    # https://wiki.fysik.dtu.dk/ase/ase/neighborlist.html
    from ase.neighborlist import neighbor_list as ase_neighbor_list
    print("\n----------------ase的neighbor_list计算结果-----------------------")
    atoms = atoms_obj
   # 实现求“ijdD”类型的邻居列表
    # cutoff = [cutoff for _ in range(len(atoms))]
    # nl = NeighborList(cutoff, skin=0.0, self_interaction=False, bothways=True)
    # nl.update(atoms)
    # indices, offsets = nl.get_neighbors(0)
    # print("indices = ", indices)
    # indices, offsets = nl.get_neighbors(1)
    # print("indices = ", indices)

    i, j, d, D = ase_neighbor_list('ijdD', atoms_obj, cutoff)
    print(len(i))
    print("i = \n", i)
    print("j = \n", j)
    print("d.shape = \n", d.shape)
    print("D.shape = \n", D.shape)


def asap3_get_neighborlist(cutoff, atoms):      
    nl = asap3.FullNeighborList(cutoff, atoms)
    pair_i_idx = []
    pair_j_idx = []
    n_diff = []
    for i in range(len(atoms)):
        indices, diff, _ = nl.get_neighbors(i)
        pair_i_idx += [i] * len(indices)               # local index of pair i
        pair_j_idx.append(indices)   # local index of pair j
        n_diff.append(diff)

    pair_j_idx = np.concatenate(pair_j_idx)
    pairs = np.stack((pair_i_idx, pair_j_idx), axis=1)
    n_diff = np.concatenate(n_diff)
    
    return pairs, n_diff




def Mo_adp_test(way=2):
    # Mo_adp = EAM(potential="./test_Mo_Ta_adp/Mo.adp", elements=['Mo'], form='adp')
    # # Mo_adp.plot('Mo_adp_test')  # 触发 Mo_rij.txt和Mo_Φij.txt数据的本地保存
    
    atoms_obj = read("Mo_structs_0.dat", format="lammps-data")
    # atoms_obj.set_chemical_symbols(['Mo' for _ in range(len(atoms_obj))])
    # Mo_adp.calculate(properties='energy', atoms=atoms_obj)

 
    # cutoff = 3  # 截断半径
    cutoff = 6.5000000000000000e+00  # Mo的adp势文件中实际的截断半径
    TorchNeigh(atoms_obj, cutoff=cutoff)

    neighbor_list = TorchNeighborList(cutoff=cutoff)   # 已经设置好了，计算截断半径内的粒子对(i, j)
    # 计算近邻列表
    pairs, pair_diff, pair_dist = neighbor_list(atoms_obj)
    print("\n<--------u11(dx)*dx, u11(dy)*dy, u11(dz)*dz-------->\n")
    print(u11(pair_diff) * pair_diff)    # mu_i^α  # 这里没有累加，只是单纯的相乘
    print((u11(pair_diff) * pair_diff).shape)   # u11(rij)*rij   # 3个方向: u11(dx)*dx, u11(dy)*dy, u11(dz)*dz
    # 测试asap3的计算结果，也是一样的
    # pairs_asap3, pair_diff_asap3 = asap3_get_neighborlist(cutoff, atoms_obj)  

    # 按列拼接
    mu_i_alpha = np.concatenate((pairs, u11(pair_diff) * pair_diff), axis=1) # mu_i_alpha[:, :2].astype(int)查看第1,2列为粒子对(i,j)的索引
    
    #------------for plotting----------
    rij_list = []
    phi_AA_list = []
    rho_i_list = []   # Electron Density rho(r)
    emb_ener_list = []
    _phi_AA_values = np.array([phi_AA(rij) for rij in pair_dist])
    _rho_i_values = np.array([rho(rij) for rij in pair_dist])
    _emb_ener_values = np.array([emb(rho_i) for rho_i in _rho_i_values])
    #------------for plotting----------
    
    pair_energy = 0.0     # ∑Φ(rij)
    embedding_energy = 0.0 # ∑F(rho_i)
    mu_energy = 0.0
    lam_energy = 0.0
    trace_energy = 0.0
    total_density = np.zeros(len(atoms_obj))
    # 参考：ase.calculators.eam.EAM中的函数和lammps的pair_adp.cpp代码
    mu = np.zeros([len(atoms_obj), 3])    # dx, dy, dz三个方向： ∑u11*dx, ∑u11*dy, ∑u11*dz # 注意：只统计[i,j]之间的,不需要再统计[j,i]之间的
    lam = np.zeros([len(atoms_obj), 3, 3])
    # print(pair_diff)
    # print(pair_diff.min(), pair_diff.max())
    # ase_neigh(atoms_obj=atoms_obj, cutoff=cutoff)   # TODO: 使用ase的neighbor_list计算效果是一致的。Q: 为什么会有重复统计的(i,j)对统计？比如(0,42)出现2次。
    # if way == 1:
    for idx, pair in enumerate(pairs):
        i, j = pair[0], pair[1]
        assert i != j, "原子对(i,j)的索引不能相同"
        # print(f"idx = {idx}, 原子对({i}, {j})之间的距离为{pair_dist[idx]:.4f}")
        # if pair_dist[idx] < cutoff:   
            # print(f"原子对({i}, {j})之间的距离为{pair_dist[idx]:.4f}")
            # print('i = {}, j = {}, phi_AA(rij) = {}'.format(i, j, phi_AA(pair_dist[idx])))
        # if i == 0:
        #     print(f"原子对({i}, {j})之间的距离为{pair_dist[idx]:.4f}")   

        rij = pair_dist[idx]   # 粒子对(i,j)之间的距离值rij
        rij_list.append(rij)
        phi_AA_list.append(phi_AA(rij))   
        rho_i = rho(rij)    # rho_i or ρi
        rho_i_list.append(rho(rij))   # Electron Density rho(ri) 
        pair_energy += phi_AA(rij) / 2.    # ∑Φ(rij) / 2
        
        emb_ener_list.append(emb(rho_i))
        embedding_energy += emb(rho_i)   # ∑ F(rho_i)
        dx, dy, dz = pair_diff[idx][0], pair_diff[idx][1], pair_diff[idx][2]

        # 测试用中心原子i=0或者53的情况
        if i == 0 or 53:
            # print(f'idx = {idx} ; rij = {rij}, u11(rij) = {u11(rij)}, dx = {dx}, dy = {dy} , dx = {dz}')
            # print(f'i={i}, j = {j}, u11(dx) = {u11(dx)}, u11(dy) = {u11(dy)}, u11(dz) = {u11(dz)}')
            print(f'i={i}, j = {j}, u11(dx)*dx = {u11(dx)*dx}, u11(dy)*dy = {u11(dy)*dy}, u11(dz)*dz = {u11(dz)*dz}')
            # pass
            
    # if way == 2:
    phi_AA_values = phi_AA(pair_dist)
    rho_i_values = rho(pair_dist) 
    emb_ener_values = emb_vec(rho_i_values)


    # plt.scatter(rij_list, phi_AA_list, s=2, c='red')
    # plt.scatter(pair_dist, _phi_AA_values, s=2, c='blue')
    # plt.scatter(pair_dist, _phi_AA_values, s=2, c='green')
    # plt.xlim(0, 6)
    # plt.ylim(-2, 2)
    # plt.legend(['scalar1', 'scalar2', 'vector'])
    # plt.savefig("Mo_phi_AA.jpg")

    # plt.scatter(rij_list, rho_i_list, s=2, c='red')
    # plt.scatter(pair_dist, _rho_i_values, s=2, c='blue')
    # plt.scatter(pair_dist, rho_i_values, s=2, c='green')
    # plt.xlim(1, 7)
    # plt.ylim(-1, 10)
    # plt.legend(['scalar1', 'scalar2', 'vector'])
    # plt.savefig("Mo_rho(r).jpg")

    # plt.scatter(rho_i_list, emb_ener_list, s=2, c='red')
    # plt.scatter(_rho_i_values, _emb_ener_values, s=2, c='blue')
    # plt.scatter(rho_i_values, emb_ener_values, s=2, c='green')
    # plt.legend(['scalar1', 'scalar2', 'vector'])
    # plt.savefig("Mo_emb_ener.jpg")






    # ------rij与Φij的关系验证-------即phi_AA
    # _rij = np.loadtxt("Mo_rij.txt")
    # _phi_rij = np.loadtxt("Mo_Φij.txt")
    # plt.xlim(0, 6)
    # plt.ylim(-2, 2)
    # plt.scatter(rij_list, phi_AA_list, marker='o')
    # plt.plot(_rij, _phi_rij, color='red')
    # plt.savefig("./Mo_rij_Φij.jpg")
    
    # ------rij与rho_i的关系验证-------
    # _rij = np.loadtxt("Mo_rij.txt")
    # _rho_i_list = np.loadtxt("Mo_rho_i.txt")
    # plt.scatter(rij_list, rho_i_list, marker='o', s=2)
    # plt.plot(_rij, _rho_i_list, color='red')
    # plt.xlim(1, 7)
    # plt.ylim(-1, 10)
    # plt.savefig("./Mo_rij_rho_i.jpg")

def TorchNeigh(atoms_obj: Atoms, cutoff: float):
    print("\n----------------TorchNeighborList方法")
    # 实例化邻居列表类
    cutoff = cutoff  # 设置截断距离
    neighbor_list = TorchNeighborList(cutoff=cutoff)

    # 计算近邻列表
    pairs, pair_diff, pair_dist = neighbor_list(atoms_obj)
    
    print("len(pairs) = ", len(pairs))
    # pairs包含原子对的索引，pair_diff是原子对之间的向量差，pair_dist是原子对之间的距离
    print("Pairs:\n", pairs)
    print("Pair differences形状：", pair_diff.shape)
    # print("Pair differences:\n", pair_diff)
    # print("Pair distances:\n", pair_dist)
    print("Pair distances形状: ", pair_dist.shape)

def Ta_adp_test():
    # 创建一个BCC晶胞的Atoms对象
    # 假设晶胞参数为a，原子类型为元素周期表号
    a = 3.32 # 晶胞参数，单位可以是埃
    element = 'Ta'  # 元素种类，例如Ta
    # 请创建一个bcc晶胞Atoms对象，用bulk命令
    atoms = bulk('Ta', 'bcc', a=a, cubic=True)

    # 定义扩展的比例
    # matrix = [[3, 0, 0], [0, 3, 0], [0, 0, 3]]  # 扩展比例矩阵
    matrix = [[2, 0, 0], [0, 2, 0], [0, 0, 2]]  # 扩展比例矩阵  SC222

    # 使用make_supercell方法扩展晶胞，这里用的是Ta的晶胞信息
    # expanded_atoms = make_supercell(atoms, matrix)
    expanded_atoms = read("test_examples2/dump.lammpstrj", format="lammps-dump-text")


    # 输出扩展后的晶胞信息
    print("扩展后的晶胞中原子数目:", len(expanded_atoms))
    print("扩展后的晶胞的单元矩阵:\n", expanded_atoms.get_cell())

    atoms_obj = expanded_atoms   # 赋值为一个超胞SC222
    # atoms_obj = atoms   # 赋值为一个单位晶胞SC111
    
    # cutoff = 3  # 截断半径
    cutoff = 6.150958970000000     # Ta的adp势文件中实际的截断半径
    TorchNeigh(atoms_obj, cutoff=cutoff)

    neighbor_list = TorchNeighborList(cutoff=cutoff)   # 已经设置好了，计算截断半径内的粒子对(i, j)
    # 计算近邻列表
    pairs, pair_diff, pair_dist = neighbor_list(atoms_obj)
    
    rij_list = []
    phi_AA_list = []
    pair_energy = 0.0     # Φ(rij)
    embedding_energy = 0.0
    mu_energy = 0.0
    lam_energy = 0.0
    trace_energy = 0.0
    total_density = np.zeros(len(atoms_obj))
    mu = np.zeros([len(atoms_obj), 3])
    lam = np.zeros([len(atoms_obj), 3, 3])
    
    for idx, pair in enumerate(pairs):
        i, j = pair[0], pair[1]
        assert i != j, "原子对(i,j)的索引不能相同"
        # print(f"idx = {idx}, 原子对({i}, {j})之间的距离为{pair_dist[idx]:.4f}")
        # if pair_dist[idx] < cutoff:   
            # print(f"原子对({i}, {j})之间的距离为{pair_dist[idx]:.4f}")
        # print('i = {}, j = {}, phi_AA(rij) = {}'.format(i, j, phi_AA(pair_dist[idx])))
        rij_list.append(pair_dist[idx])
        phi_AA_list.append(phi_AA(pair_dist[idx]))
        pair_energy += phi_AA(pair_dist[idx]) / 2.
    
    plt.xlim(0, 6)
    plt.ylim(-1, 1)
    plt.scatter(rij_list, phi_AA_list)
    plt.savefig("./Ta_rij_Φij.jpg")
    
            


if __name__ == "__main__":
    # 测试例子：借用Mo的adp势函数，来预测扩胞SC222的Ta晶体构型能量
    # Ta_adp_test()
    Mo_adp_test()
    # pass